# 算法2022复习题

## 复习资料

### 一、简答题： 

1、什么是时间复杂度？

​	定性描述一个算法的运行时间

2、什么是STL？

​	英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。

3、什么是空间复杂度？

​	一个算法在运行过程中临时占用存储空间大小的量度

4、什么是直接递归和间接递归？

​	直接递归调用  调用的是**函数本身**；

​	间接递归调用  调用的是**其他函数**。

5、消除递归一般用到什么数据结构？

​	栈来做消除递归，模拟内存处理过程。



```java
//状态机：看卡即可
//要存储的数据
class Data{
    //方法参数
    int n;
    //返回地址
    int returnAddress;
    //构造器及getter，setter
    ...
}

//栈
Stack<Data> myStack = new Stack<>();

//状态机实现运算过程
    public static int execute(int num){
        int i = 1;   
        int result = 1;
        while(i!=6){       //结束
            switch(i){
                case 1:     //初始化
                    i=2;
                    break;
                case 2:     //条件是否结束
                    if(num==1){
                        result=1;
                        i=4;
                    }else{
                        i=3;
                    }
                    break;
                case 3:     //递归入栈
                    Data data = new Data(num);
                    myStack.push(data);
                    num--;   //条件发生变化
                    i=2;
                    break;
                case 4:     //栈是否空
                    if(myStack.isEmpty()){
                        i=6;
                    }else{
                        i=5;
                    }
                    break;
                case 5:     //回溯出栈
                    Data data1 = myStack.pop();
                    result*=data1.n;
                    i=4;
                    break;
                }
        }
        return result;
    }
```

6、简述分治法的设计思想

​	**将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之**

7、动态规划是将多阶段决策问题进行公式化的一种技术，动态规划算法一般要具有3个性质，是哪三个性质并对这三个性质进行简要的说明。

**（1）最优化原理：**假设问题的最优解所包括的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。

**（2）无后效性：**即某阶段状态一旦确定。就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响曾经的状态。仅仅与当前状态有关；

**（3）有重叠子问题：**即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到（该性质并非动态规划适用的必要条件，可是假设没有这条性质。动态规划算法同其它算法相比就不具备优势）。

### 二、计算题

计算时间复杂度

> 先找出变量值i和循环内代码执行次数t之间的函数关系，当变量值等于跳出循环值n的时候，解出t
>
> ```
> int i=1,n;
> while(i<n/2){
>     i=i*2;
> }
> ```
>
> | 次数:   | 第0次 | 第1次 | 第2次 | 第3次 | 第t次                                                        |
> | ------- | ----- | ----- | ----- | ----- | ------------------------------------------------------------ |
> | 变量值: | i=1   | i=2   | i=4   | i=8   | i=![](https://blog-images-djx.oss-cn-hangzhou.aliyuncs.com/img/gif.latex) |
>
> 找出函数关系后，当变量值等于跳出循环值的时候，也就是i=n/2时，也就是i=![2^{t}](https://blog-images-djx.oss-cn-hangzhou.aliyuncs.com/img/202205232058272.gif)=n/2时，解出t就是时间复杂度了。也就是![\log_{2}\frac{n}{2}](https://blog-images-djx.oss-cn-hangzhou.aliyuncs.com/img/202205232058747.gif)



[嵌套循环](https://blog.csdn.net/qq_40878688/article/details/83719910)

[快速排序](https://www.cnblogs.com/fengty90/p/3768827.html)

[递归](https://blog.csdn.net/ypxcan/article/details/120452530)

### 三、程序设计题

#### 1、用蛮力法求解

给定n个整数表示一个商店连续n天的销售量。如果某天之前销售量在增长，而后一天销售量减少，则称这一天为折点，反过来如果之前销售量减少而后一天销售量增长，也称这一天为折点。其他的天都不是折点。如下图中，第3天和第6天是折点。

![image-20220523195158561](https://blog-images-djx.oss-cn-hangzhou.aliyuncs.com/img/202205231951696.png)

　　给定n个整数a1, a2, …, an表示销售量，请计算出这些天总共有多少个折点。
 　为了减少歧义，我们给定的数据保证：在这n天中相邻两天的销售量总是不同的，即ai-1≠ai。注意，如果两天不相邻，销售量可能相同。

输入格式

　　输入的第一行包含一个整数n。

　　第二行包含n个整数，用空格分隔，分别表示a1, a2, …, an。

输出格式

　　输出一个整数，表示折点出现的数量。

样例输入

7

5 4 1 2 3 6 4

样例输出

2

评测用例规模与约定

　　所有评测用例满足：1 ≤ n ≤ 1000，每天的销售量是不超过10000的非负整数。

解：参考代码

```c++
#include <stdio.h>
#define N 1000
int a[N];
int main(void)
{
  int n, i, count;
  // 读入数据
  scanf("%d", &n);
  for(i=0; i<n; i++)
    scanf("%d", &a[i]);
  // 计算折点
  count = 0;
  for(i=1; i<n-1; i++)
    if((a[i-1] < a[i] && a[i] > a[i+1]) || (a[i-1] > a[i] && a[i] < a[i+1]))
     count++;
  // 输出结果
  printf("%d\n", count);
	return 0;
}
```

```java
//JAVA算法：
```



#### 2、用蛮力法求解

小明正在利用股票的波动程度来研究股票。小明拿到了一只股票每天收盘时的价格，他想知道，这只股票连续几天的最大波动值是多少，即在这几天中某天收盘价格与前一天收盘价格之差的绝对值最大是多少。

输入格式

　　输入的第一行包含了一个整数n，表示小明拿到的收盘价格的连续天数。

　　第二行包含n个正整数，依次表示每天的收盘价格。

输出格式

　　输出一个整数，表示这只股票这n天中的最大波动值。

样例输入

6

2 5 5 7 3 5

样例输出

4

样例说明

　　第四天和第五天之间的波动最大，波动值为|3-7|=4。

评测用例规模与约定

　　对于所有评测用例，2 ≤ n ≤ 1000。股票每一天的价格为1到10000之间的整数。

解：参考代码

```c++
#include <stdio.h>
#define MAX(x, y) ((x > y) ? (x) : (y))
int main(void)
{
  int n, first, second, delta, maxval=0;
  // 输入n，输第１个数（从逻辑上来说应该写两句，为了简洁只需要写一句）
  scanf("%d%d", &n, &first);
  while(--n) {
    //　输入第2至第n个数
    scanf("%d", &second);
    // 求差值（波动值），取绝对值，求最大值
   delta = second - first;
    if(delta<0)
      delta = -delta;
    maxval = MAX(maxval, delta);
    first = second;
  }
  // 输出结果
  printf("%d\n", maxval);
  return 0;
}
```

```java
//JAVA算法：
```



#### 3、用分治法求解

问题描述

　　在一个整数序列a1, a2, …, an中，如果存在某个数，大于它的整数数量等于小于它的整数数量，则称其为中间数。在一个序列中，可能存在多个下标不相同的中间数，这些中间数的值是相同的。

　　给定一个整数序列，请找出这个整数序列的中间数的值。

输入格式

　　输入的第一行包含了一个整数n，表示整数序列中数的个数。

　　第二行包含n个正整数，依次表示a1, a2, …, an。

输出格式

　　如果约定序列的中间数存在，则输出中间数的值，否则输出-1表示不存在中间数。

样例输入

6

2 6 5 6 3 5

样例输出

5

样例说明

　　**比5小的数有2个，比5大的数也有2个。**

样例输入

4

3 4 6 7

样例输出

-1

样例说明

　　在序列中的4个数都不满足中间数的定义。

样例输入

5

3 4 6 6 7

样例输出

-1

样例说明

　　在序列中的5个数都不满足中间数的定义。

评测用例规模与约定

　　对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ ai ≤ 1000。

解：参考代码

```c++
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 1000;
int val[N];
int main()
{
  int n, mid, leftcount, rightcount;
  // 输入数据
  cin >> n;
  for(int i=0; i<n; i++)
    cin >> val[i];
  // 排序
  sort(val, val+n);
  // 找出中间数
  mid = n / 2;
  leftcount = mid;
  rightcount = n - mid - 1;
  // 去掉左边与中间相同值数的个数
  for(int i=mid-1; i>=0; i--)
    if(val[i] == val[mid])
      leftcount--;
    else
      break;
  // 去掉右边与中间相同值数的个数
  for(int i=mid+1; i<n; i++)
    if(val[i] == val[mid])
      rightcount--;
    else
      break;
  // 输出结果
  if(leftcount == rightcount)
    cout << val[mid] << endl;
  else
    cout << -1 << endl;
  return 0;
}
```

```java
//JAVA算法：
```



#### 4、求解逆序数问题

  给定一个整数数组a[n]，若i<j，a[i]>a[j]，则<a[i],a[j]>称为一个逆序对。例如：数组（3，1，4，5，2）的逆序对有<3,1>，<3,2>，<4,2>，<5,2>，其逆序对的个数称为逆序数，如数组（3，1，4，5，2）的逆序数为4.

请用分治法设计一个程序解决之并分析其时间复杂度。

解：参考代码

时间复杂度为o(nlgn)。

```c++
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
//int num =0;
void merge(int in[], int out[], int l, int m, int r,int &num)
{
    int i = l;
    int k  = m + 1;
    while (l <= m && k <= r) 
    { 
        if (in[l] <= in[k]) {
        out[i++] = in[l++];
        } 
        else 
       {
            out[i++] = in[k++];
           /* 因为此时in[l...m]已经排序，如果in[l] 与 in[k] 逆序,
            则in[l+1], in[l+2]...in[m] 都与in[k]逆序, 共 m-l+1 对*/
           num += m - l +1; /* calculate the inversion number */
        }
    }
    while (l <= m) {
    out[i++] = in[l++];
    }
    while (k <= r) {
    out[i++] = in[k++];
    }
 
}
/*
* @brief 递归将序列划分为只有一个元素的子序列, 然后逐次对子序列进行合并
*/
void m_sort(int in[], int out[], int l, int r,int &num)
{
/* 仅有一个元素, 已排序, 递归结束 */
    if (l >= r) {
    return;   
    }
     /* 计算 l 和 r 的中间值, 防止溢出 */
    int m = (l & r) + ((l ^ r) >> 1);
    /* note that in and out are swapped */
    m_sort(out, in, l, m,num);
    m_sort(out, in, m + 1, r,num);
    merge(in, out, l, m, r,num);
}
/*
* @brief merge sort
* 统一申请空间, 避免反复申请释放
*/
int merge_sort(int a[], int n,int &num)
{
    int *b = (int *)malloc(n * sizeof(int));
    if (b) {
    memcpy(b, a, n * sizeof(int));
    m_sort(b, a, 0, n - 1,num);
    free(b);
    return 0;
    } 
    return -1;
}
int main()
{
    int sum=0;
    int a[9]={2,1,3,8,5,7,4,6,10};
    merge_sort(a,9,sum);
    for(int i=0;i<9;i++)
    printf("%d   ",a[i]);
    printf("\n");
    printf("逆序对的数目为sum=%d",sum);
    printf("\n");
    return 0;
}
```

```java
//JAVA算法：
```



#### 5、逆置单链表

对于一个不带头结点的单链表L，设计一个递归算法逆置所有结点。编写完整的程序并进行测试，分析其时间复杂度

解：基本思想：

 将逆置一个单链表L表示为一个整体的大问题，如果L->next已经逆置了，此时只需要将L链接到L->next的节点末尾就可以了。逆置单链表L被分解成了小问题逆置单链表L->next。二者具有相同的求解结构。

参考代码：

```c++
#include<iostream>
using namespace std;

// 定义一个单链表
struct linkedList{
    int value;
    linkedList *next;

    // 构造函数
    linkedList(){}
    linkedList(int _value, linkedList * _next) : value(_value), next(_next){}
};

// 初始化一个单链表数据
linkedList* initList(){
    int nums[] = {1,2,3,4,5,6,7,8};
    // 分配空间以及初始化
    linkedList *head = new linkedList(nums[0], NULL);
    if(!head) exit(1);

    // 将单链表线性连接 A -> B -> C ...
    linkedList *temp = head;
    for(int i=1; i<8; i++){
        linkedList *newNode = new linkedList(nums[i], NULL);
        if(!newNode) exit(1);
        temp -> next = newNode;
        temp = newNode;
    }
    return head;
}

// 打印单链表
void printList(linkedList *list){
    while (list){
        cout << list->value;
        if(list->next){
            cout << " -> ";
        }
        list = list->next;
    }
    cout << endl;
}

// 逆置一个单链表
linkedList* reverseList(linkedList *list){
    // 如果当前节点为空，则返回前一个节点的地址，递归结束
    if(!list || !list -> next){
        return list;
    }
    linkedList *p = reverseList(list -> next);
    list -> next -> next = list;
    list -> next = NULL;
    return p;
}

int main()
{
    // 初始化
    linkedList *list = initList();
    cout<<"逆置前: ";
    printList(list);
    // 逆置单链表
    list = reverseList(list);
    cout<<"逆置后: ";
    printList(list);
    return 0;
}

```

```java
//JAVA算法：
```



#### 6、gcd

设计一个递归算法求二个正整数x,y的最大公约数（gcd）,并转换为非递归算法

解：参考代码

```c++
#include<iostream>
using namespace std;

// 递归实现gcd算法
int gcd(int num1, int num2){
    int remainder = num1 % num2;
    return remainder == 0 ? num2 : gcd(num2, remainder);
}

// 非递归实现gcd算法
int gcd_common(int num1, int num2){
    int remainder = num1 % num2;
    while(remainder){
        num1 = num2;
        num2 = remainder;
        remainder = num1 % num2;
    }
    return num2;
}

int main(){
    int num1, num2;
    while (cin >> num1 >> num2){
        cout << gcd(num1, num2) << endl;
    }
    return 0;
}

```

#### 7、二个函数f(x)和g(x)

小明同学在学习了不同进制之后用数字做起了游戏。小明同学定义了二个函数f(x)和g(x)，f(x)求解x的十进制表示的各位数字之和，g(x) 求解x的二进制表示的各位数字之和，例如：f(123)=1+2+3=6； 123的二进制表示为：1111011，g(123)=1+1+1+1+0+1+1=6。小明同学发现一些整数满足f(x)=g(x)，如：f(123)=g(123)，他把这种数称为幸运数，现在他想知道不大于n的幸运数有多少个？

请设计一个递归算法求解该问题并分析其时间复杂度

解：参考代码

```c++
#include<iostream>
using namespace std;

// HEX进制下，实现对num的每一位求和
int getSum(int num, int HEX){
    int sum = 0;
    if(num < HEX) return num;
    return num % HEX + getSum(num / HEX, HEX);
}

int main(){
    int n;
    cin >> n;
    int sum = 0;
    for(int i=1; i<=n; i++){
        if(getSum(i, 10) == getSum(i, 2)){
            sum++;
        }
    }
    cout << sum <<endl;
    return 0;
}

```

```java
//JAVA算法：
```



#### 8、求解查找假币问题

有n(n>3)个硬币，其中有一个假币，且假币较轻，用天平称重得到其重量为w[i],请设计一个程序，用分治法实现，并分析其时间复杂度。

解：基本思想：

将假币分成两份去称，轻的那一半包含假币，将轻的那一半又分为两份，接着称，直到剩下最后两枚，轻的那一枚即为假币。

注意硬币个数可能为奇数，照样分为两半，剩下一个多余的，如果两半等重，多余的那枚即为假币，否则继续处理剩下两半。

参考代码：

```c++
#include <iostream>
#include <cstdlib>
using namespace std;

int FakeCoin(int Coins[], int low, int high)
{
    if ((high - low) == 1)
        return Coins[high] < Coins[low] ? high : low;
    if ((high - low) % 2 == 1) //硬币总数为偶数
    {
        cout << "偶数" << endl;
        int mid = (low + high) / 2;
        int left = 0, right = 0;
        for (int i = 0; i <= mid; i++)
            left += Coins[i];
        for (int i = mid + 1; i <= high; i++)
            right += Coins[i];
        if (left < right)
        {
            cout << "左 " << low << " " << high << endl;
            return FakeCoin(Coins, low, mid);
        }
        else
        {
            cout << "右" << mid + 1 << " " << high << endl;
            return FakeCoin(Coins, mid + 1, high);
        }
    }
    else //硬币总数为奇数
    {
        cout << "奇数" << endl;
        int mid = (low + high) / 2;
        int left = 0, right = 0;
        for (int i = 0; i < mid; i++)
            left += Coins[i];
        for (int i = mid + 1; i <= high; i++)
            right += Coins[i];
        if (left == right)
        {
            cout << "正好在中间" << endl;
            cout << mid << endl;
            return mid;
        }
        else if (left < right)
        {
            cout << "左" << low << " " << mid << endl;
            return FakeCoin(Coins, low, mid);
        }
        else
        {
            cout << "右" << mid << " " << high << endl;
            return FakeCoin(Coins, mid, high);
        }
    }
}

int main()
{
    int n;
    int Coins[25] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2};
    cout << FakeCoin(Coins, 0, 24);
    system("pause");
    return 0;
}

```

```java
//JAVA算法：
```



#### 9、回溯法求解查找假币问题

有12个硬币，用A-L表示，其中有一个假币，且假币较轻，真币重量相同。每次选择4个硬币放置于天平的左托盘或右托盘进行称重，得到如下结果：

ABCD EFGH even   //even表示二边一样重，天平平衡

ABCI EFJK up //up表示前者重，ABCI重量大于EFJK重量，天平不平衡；down表示后者重

ABIJ EFGH even   //even表示二边一样重，天平平衡

用回溯法实现求解之。

解：基本思想：

 暴力+回溯法，不妨默认所有硬币都是真的，依次进行假设，假设硬币i是假币，代入已知的测试结果，满足所有测试数据说明假设正确， 硬币i是假币。如果至少有一条测试数据不满足，说明假设错误，该硬币为真币，回溯，对下一个硬币进行假设

参考代码

```c++
#include<iostream>
using namespace std;

// 已知的测试数据 (每次左托盘放的硬币、右托盘放的硬币、该次比较的结果)
string test_data_left[3] = {"ABCD", "ABCI", "ABIJ"};
string test_data_right[3] = {"EFGH", "EFJK", "EFGH"};
string test_result[3] = {"even", "up", "even"};

// 假设所有硬币都是真币，重量相同
int weight[12]={0};

bool isFakeCoin(){
    for(int i=0; i<3; i++){
        int left_weight = 0;
        int right_weight = 0;
        // 在已经对某一个硬币进行假设的情况下，统计估计值
        for(int j=0; j<test_data_left[i].length(); j++){
            left_weight += weight[test_data_left[i][j]-'A'];
        }
        for(int j=0; j<test_data_right[i].length(); j++){
            right_weight += weight[test_data_right[i][j]-'A'];
        }
        // 判断估计值与已知的测试数据符不符合，全部符合说明该币是假币，估计正确。
        // 有一条结果不满足说明估计错误，直接返回，对其他硬币进行估计
        
        if(left_weight > right_weight && test_result[i] != "up"){
            return false;
        }
        
        if(left_weight == right_weight && test_result[i] != "even"){
            return false;
        }

        if(left_weight < right_weight && test_result[i] != "down"){
            
            return false;
        }
    }
    return true;
}

int judge(){
    // 对所有硬币依次进行假设
    for(int i=0; i<12; i++){
        // 假设硬币i是假币，且重量较轻
        weight[i] = -1;
        // 判断是不是假币
        if(isFakeCoin()){
            return i;
        }
        // 假设硬币i是假币，且重量较重
        weight[i] = 1;
        // 判断是不是假币
        if(isFakeCoin()){
            return i;
        }
        // 执行到这里说明硬币i不是假币, 回溯, 重置为真币
        weight[i] = 0;
    }
    return 0;
}

int main(){
    cout << "假币是: " << char(judge() + 'A') << endl;
    return 0;
}

```

```java
//JAVA算法：
```



#### 10、a,b,c,d,e取值互不相同

a,b,c,d,e取值互不相同，为1到5中的一个数，满足ab-cd-e=1方程，用回溯法设计求解该方程。

解：参考代码

```c++
#include<iostream>
#define N 5
using namespace std;

// a 表示一种1-5的组合方式
int a[N] = {0};
// 数字 i 是否被使用过
int used[N+1]={0};

// 求全排列
void dfs(int len){
    if(len == N){
        if((a[0]*a[1] - a[2]*a[3] - a[4]) == 1){
            printf(" %d * %d - %d * %d - %d = 1 \n", a[0], a[1], a[2], a[3], a[4]);
        }
        return ;
    }
    for(int i=1; i<=N; i++){
        if(!used[i]){
            // 标记数字i被使用
            used[i] = 1;
            a[len] = i;
            dfs(len+1);
            // 回溯, 标记数字i未被使用
            used[i] = 0;
        }
    }
    return ;
}
int main(){
    dfs(0);
    return 0;
}

```

```java
//JAVA算法：
```



#### 11、0-1背包问题

（有n个重量分别为w[1]、w[2] ……w[n]的物品（物品编号为1～n），它们的价值分别为v[1]、v[2] ……v[n]，给定一个重量容量为W的背包，每个物品要么选中要么不选中，在不超重下，使得放入背包的物品价值最大。请用分枝限界法编程解决之，要求编写完整的程序并进行测试，分析其时间复杂度。

解：参考代码

```
#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
#define MAXNUM 10000

// 物品，重量和价值
struct Goods
{
    int weight;
    int value;
    // 平均价值 value/weight
    double average_value;
} goods[MAXNUM];

// 对应二叉树节点
struct GoodsNode
{
    // 位于二叉树的第几层
    int layer;
    // 当前节点的总重量
    int weight;
    // 当前节点的总价值
    int value;
    // 上界
    double up_bound;
    // 重载<运算符，优先队列中需要使用，按照up_bound的优先级保证队列有序
    bool operator<(const GoodsNode &a) const
    {
        return up_bound < a.up_bound;
    }
};

// 物品数量
int n;
// 背包重量
int limit_weight;

// 最优值（最大价值）
int maxValue = -1;

// 用于sort排序的自定义排序规则
bool cmpValue(Goods a, Goods b)
{
    return a.average_value > b.average_value;
}

// 获取上界，此处获取的是理想情况下的最优值，按照平均价值算的，所以实际价值 <= up_bound
void getUpBound(GoodsNode &g)
{
    // 二叉树的层级，对应第几个商品
    int layer = g.layer + 1;
    // 当前节点的重量和价值
    int sum_weight = g.weight;
    double sum_value = g.value;
    while ((layer < n) && (sum_weight + goods[layer].weight <= limit_weight))
    {
        sum_weight += goods[layer].weight;
        sum_value += goods[layer].value;
        layer++;
    }
    // 理想情况下的最大价值
    if (layer < n)
    {
        g.up_bound = sum_value + (limit_weight - sum_weight) * goods[layer].average_value;
    }
    else
    {
        g.up_bound = sum_value;
    }
}

void pushQueue(priority_queue<GoodsNode> &q, GoodsNode g)
{
    // 到达叶节点，相当于一种背包组合方式选择完成了
    if (g.layer == n)
    {
        if (g.value > maxValue)
        {
            maxValue = g.value;
        }
    }
    else
    {
        q.push(g);
    }
}

// 求解0/1背包问题
void knapsack()
{
    priority_queue<GoodsNode> maxUpBound;
    // 当前节点，左子节点，右子节点
    GoodsNode node, leftNode, rightNode;
    // 初始节点，未选择任何商品，层级-1
    node.layer = -1;
    node.weight = 0;
    node.value = 0;
    // 其上界是最理想的取值情况，实际价值小于等于上界的值
    getUpBound(node);
    // 加入到上界的优先队列中
    maxUpBound.push(node);
    while (!maxUpBound.empty())
    {
        // 取出最优取值情况
        node = maxUpBound.top();
        maxUpBound.pop();
        // 在当前最优分枝中继续判断左子节点，如果左子节点是活节点，加入优先队列，否则剪枝
        if ((node.weight + goods[node.layer + 1].weight) <= limit_weight)
        {
            leftNode.layer = node.layer + 1;
            leftNode.weight = node.weight + goods[node.layer + 1].weight;
            leftNode.value = node.value + goods[node.layer + 1].value;
            getUpBound(leftNode);
            pushQueue(maxUpBound, leftNode);
        }
        // 判断右子节点是否需要剪枝，上界可行则加入优先队列
        rightNode.layer = node.layer + 1;
        rightNode.weight = node.weight;
        rightNode.value = node.value;
        getUpBound(rightNode);
        if (rightNode.up_bound > maxValue)
        {
            pushQueue(maxUpBound, rightNode);
        }
    }
}

int main()
{
    // 输入背包重量，物品数量
    cin >> limit_weight >> n;
    // 输入每件物品的重量和价值
    for (int i = 0; i < n; i++)
    {
        cin >> goods[i].weight >> goods[i].value;
        goods[i].average_value = goods[i].value * 1.0 / goods[i].weight;
    }
    // 按平均价值排序（贪心思想，先选重量小，价值高的）
    sort(goods, goods + n, cmpValue);
    knapsack();
    cout << maxValue;
    return 0;
}

```

```java
//JAVA算法：
```



#### 12、求解矩阵最小路径和问题

给定一个m行n列的矩阵，从左上角开始每次只能向右或者向下移动，最后到达右下角的位置，路径上的所有数字累加起来作为这条路径的路径和。如下面一个4行4列的矩阵：

1  3  5  9

8  1  3  4

5  0  6  1

8  8  4  0

1→3→1→0→6→1→0是所有路径和最小的，12.

请用动态规划编程解决之。要求编写完整的程序。

解：基本思想：

 递推方程如下：

> dp[0][0] = a[0][0];
>
> dp[0][i] = a[0][i] + dp[0][i-1];
>
> dp[i][0] = a[i][0] + dp[i-1][0];  
>
> dp[i][j] = a[i][j] + min(dp[i-1][j], dp[i][j-1]); ( i>=1, j>=1 )

参考代码

```c++
#include <iostream>
using namespace std;
int main(){
    // m行 n列
    int m, n;
    int a[100][100];
    // dp[i][j] 表示从起点到（i, j）的最小值
    int dp[100][100];
    cin >> m >> n;
    for(int i=0; i<m; i++){
        for(int j=0; j<n; j++){
            cin >> a[i][j];
        }
    }
    dp[0][0] = a[0][0];
    for(int i=1; i<n; i++){
        dp[0][i] = a[0][i] + dp[0][i-1];
    }
    for(int i=1; i<n; i++){
        dp[i][0] = a[i][0] + dp[i-1][0];
    }
    for(int i=1; i<m; i++){
        for(int j=1; j<n; j++){
            dp[i][j] = a[i][j] + min(dp[i-1][j], dp[i][j-1]);
        }
    }
    cout << dp[m-1][n-1] << endl;
    return 0;
}

```

```java
//JAVA算法：
```



#### 13、求解买股票问题

“逢低吸纳”是炒股的一条成功秘诀，如果你想成为一个投资者，就要遵守这条秘诀。“逢低吸纳，越低越买”，这句话的意思是每次你购买股票时的股价一定要比你上次购买时的股价低。按照这个规则购买股票的次数越多越好，看看你最多能按这个规则买几次。

输入描述：第1行为整数N(1≤N≤5000)，表示能买股票的天数；第2行及以下是N个正整数（可能有多行），第i个正整数表示第i天的股价。

输出描述：按照规则能买进股票的最多天（次）数

输入样例：

12

68 69 54 64 68 64 70 67 78 62 98 87

输出样例：

4

请用动态规划编程解决之。

解：参考代码

```c++
#include <iostream>
using namespace std;
int main(){
    int n;
   cin >> n;
    int a[100];
    int dp[100];
    for(int i=0; i<n; i++){
		cin >> a[i];
        dp[i] = 1;
    }
    int maxLength = -1;
    for(int i=0; i<n; i++){
        for(int j=0; j<i; j++){
            if(a[i] < a[j]){
                dp[i] = dp[i] > dp[j]+1 ? dp[i] : dp[j]+1;
            }
            maxLength = dp[i] > maxLength ? dp[i] : maxLength;
        }
    }
    cout << maxLength <<endl;
    return 0;
}
```

```java
//JAVA算法：
```

